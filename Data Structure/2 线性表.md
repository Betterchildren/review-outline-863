## 线性表

### 线性表的定义、基本操作
**线性表**是n个数据元素的有限序列。  
初始化线性表，销毁线性表，将表置空，判断是否为空，求表长，获得指定索引的值，插入元素，删除元素，求前驱或后继……

### 线性表的实现及应用

#### 顺序存储结构
用一组地址连续的存储单元依次存储线性表的数据元素。

##### 构造原理
设有非空的线性表 $(a_1, a_2, \dots a_n)$，每个元素需占用 $l$ 个存储单元，则线性表的第 $i$ 个数据元素 $a_i$ 的存储位置为 $LOC(a_i) = LOC(a_i) + (i-1)\times l$。其中 $LOC(a_1)$ 是线性表的第一个数据元素的存储位置，通常称作线性表的起始位置或基地址。  
``` c
// --- 线性表的动态分配顺序存储结构 ---
#define LIST_INIT_SIZE 100  // 线性表存储空间的初始分配量
#define LISTINCREMENT  10   // 线性表存储空间的分配增量
typedef struct{
    ElemType *elem;     // 存储空间基址
    int      length;    // 当前长度
    int      listsize;  // 当前分配的存储容量（以 sizeof(ElemType)为单位）
}SqList;
```

##### 主要操作的算法设计与实现
###### 初始化线性表
``` c
Status InitList_Sq(SqList *L){
    // 创造一个空的线性表L
    L->elem = (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType));
    if (! L->elem) exit(OVERFLOW);  // 存储分配失败
    L->length = 0;                  // 空表长度为0
    L->listsize = LIST_INIT_SIZE;   // 初始存储容量
    return OK;
}
```

###### 插入元素
插入一个元素后，需要将原该位置至最后一个元素向右移动一位。  
``` c
Status ListInsert_Sq(SqList *L, int i, ElemType e){
    // 在顺序线性表 L 中第 i 个位置之前插入新的元素 e
    // i 的合法值为 [1, ListLength_Sq(L) + 1]
    if(i < 1 || i > L->length+1) return ERROR;  // i 值不合法
    if(L->length >= L->listsize){       // 当前存储空间已满，增加分配
        ElemType *newbase = (ElemType *)realloc(L->elem,
        			(L->listsize+LISTINCREMENT) * sizeof(ElemType));
        if (! newbase) exit(OVERFLOW);   // 存储分配失败
        L->elem = newbase;               // 新基址
        L->listsize += LISTINCREMENT;    // 增加存储容量
    }
    ElemType *q = &(L->elem[i-1]);       // q 为插入位置
    ElemType *p;
    for(p = &(L->elem[L.length - 1]); p>=q; --p)
    	*(p+1) = *p;                    // 插入位置及之后的元素右移
    *q = e;           // 插入 e
    ++L->length;      // 表长增1
    return OK;
}
```
平均时间复杂度为 $O(n)$。

###### 删除元素
删除一个元素后，需要将原该位置至最后一个元素向左移动一位。  
``` c
Status ListDelete_Sq(SqList *L, int i, ElemType *e){
    // 在顺序线性表 L 中删除第 i 个元素，并用 e 返回其值
    // i 的合法值为 [1, ListLength_Sq(L)]
    if(i < 1 || i > L->length) return ERROR; // i 值不合法
    ElemType *p, *q;
    p = &(L.elem[i-1]);                      // p 为被删除元素的位置
    *e = *p;                                 // 被删除元素的值赋给 e
    q = L->elem + L->length - 1;             // q 为表尾元素的位置
    for(++p; p<=q; ++p)
    	*(p-1) = *p;                         // 删除位置及之后的元素左移
    --L.length;                              // 表长减1
    return OK;
}
```
平均时间复杂度为 $O(n)$。

###### 定位元素
###### 顺序表的合并

#### 链式存储结构

##### 单链表、循环链表和双向链表

##### 构造原理

##### 主要操作的算法设计与实现
