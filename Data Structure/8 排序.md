## 排序
### 基本概念
* **排序**（sorting）是将一个数据元素（或记录）的任意序列，重新排成一个按关键字有序的序列。
* 当输入含重复关键字时，若重复元素在输入、输出序列中的相对次序保持不变，则称该排序算法是**稳定的**。
* 若整个排序过程中数据元素全部存放在内存，不需要访问外存便能完成，则称此类排序为**内部排序**；反之，若参加排序的记录数量很大，不能同时放在内存，必须不断在内、外存之间移动的排序称为**外部排序**。

### 算法原理与复杂度
#### 直接插入排序
直接插入排序（straight insertion sort）是一种最简单的排序方法，基本操作是将一个记录插入到已排好序的有序表中，从而得到一个新的、记录数增1的有序表。 
``` c
void InsertSort(SqList *L){
    for(int i = 2; i <= L->length; ++i){
        if(LT(L->r[i].key, L->r[i-1].key)){
            L->r[0] = L->r[i];       // 复制为哨兵
            L->r[i] = L->r[i-1];
            for(int j = i - 2; LT(L->r[0].key, L->r[j].key); --j)
                L->r[j+1] = L.r[j];  // 记录后移
            L->r[j+1] = L->r[0];     // 插入到正确位置
        }
    }
}
```
时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

#### 折半插入排序
将插入过程中的查找操作改用折半查找来实现，称为折半插入排序（binary insertion sort）。  
空间复杂度也为 $O(1)$，而由于移动操作所需时间与顺序插入排序相同，故时间复杂度也相同，为 $O(n^2)$。

#### 气泡排序
依次比较每一对相邻元素，若有必要则交换，一趟排序之后最大值必然就位。重复上述操作直至有序即为气泡排序（bubble sort）。  
``` c
void BubbleSort(SqList *L){
    int i = L->length;
    bool sorted = false;
    while(!sorted){   // 第[i...n]大元素已排序，寻找第 i-1 大元素
        sorted = true;
        for(int j = 1; j < i; j++)  // 从[i...i-1]寻找第 i-1 大元素
            if(L->r[j+1].key < L->r[j].key){  // 将大的记录后移
                Swap(L->r[j+1], L->r[j]);
                sorted = false;    // 记下进行交换的记录
            }
        i--;
    }
}
```
时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

#### 简单选择排序
一趟简单选择排序（simple selection sort）的操作为：通过 n-i 次关键字间的比较，从 n-i+1 个记录中选出关键字最小的记录，并和第 i 个记录交换。  
时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

#### 快速排序
快速排序（quick sort）的基本思想为通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分小，则可分别对这两部分继续排序，最终达到整个序列有序。
``` c
int Partition(SqList *L, int low, int high){
    // 交换顺序表中子表 r[low...high] 的记录
}
```

#### 堆排序
#### 二路归并排序
#### 基数排序
#### 外部排序

### 排序算法的应用
