## 树与二叉树
树及图部分尤其推荐结合图片理解。

### 树
* **树**（tree）是 $n(n\geq 0)$ 个结点的有限集。  
* 在任意一棵非空树中，有且仅有一个称为**根**（root）的结点，当 $n>1$ 时，其余结点可分为 $m(m>0)$ 个互不相交的有限集，其中每一个集合本身又是一棵树，称为根的**子树**（subtree）。  
* 结点拥有的子树数称为结点的**度**（degree），树的度为树中所有结点的最大值，度为0的结点称为**叶子**（leaf）或**终端结点**，度不为0的结点称为**分支结点**或**非终端结点**。  
* 结点的子树的根称为该结点的**孩子**（child），该结点称为孩子的**双亲**（parent），同一个双亲的孩子之间互称**兄弟**（sibling），结点的**祖先**是从根到该结点所经分支上的所有结点，以某结点为根的子树中的任一结点都称为该结点的**子孙**。  
* 如果将树中结点的各子树看成从左至右是有次序的，则称该树为**有序树**，否则成为**无序树**。  
* 结点的**层次**（level）从根开始定义起，根为第一层，根的孩子为第二层。树中结点的最大层次称为树的**深度**（depth）。
* **森林**（forest）是 $m(m\geq 0)$ 课互不相交的树的集合。

### 二叉树
#### 概念
**二叉树**（binary tree）的特点是每个结点至多只有两棵子树，且是有序树。  

#### 性质
* 在二叉树的第 $i$ 层上至多有 $2^{i-1}$ 个结点 $(i\geq 1)$。
* 深度为 $k$ 的二叉树至多有 $2^k-1$ 个结点 $(k\geq 1)$。
* 对任何一棵二叉树 $T$，如果其终端结点数为 $n_0$，度为2的结点数为 $n_2$，则 $n_0=n_2+1$。

一棵深度为 $k$ 且有 $2^k-1$ 个结点的二叉树称为**满二叉树**（full binary tree）。  
树中所含的 $n$ 个结点与同深度满二叉树中从上到下、从左到右编号为1至 $n$ 的结点一一对应时，称为**完全二叉树**（complete binary tree）。  
完全二叉树的两个重要性质：
* 具有 $n$ 个节点的完全二叉树深度为 $\lfloor \log_2n \rfloor+1$。
* 如果对一棵有 $n$ 个结点的完全二叉树的结点按层序编号，则对任一结点 $i(1\leq i \leq n)$ 有：
* * 如果 $i=1$，则结点 $i$时二叉树的根，无双亲；如果 $i>1$，则其双亲 PARENT($i$) 是结点 $\lfloor i/2 \rfloor$。
* * 如果 $2i>n$，则结点 $i$ 无左孩子（结点 $i$ 为叶子结点）；否则其左孩子 LCHILD($i$) 是结点 $2i$。
* * 如果 $2i+1>n$，则结点 $i$ 无右孩子；否则其右孩子 RCHILD($i$) 是结点 $2i+1$。

#### 顺序存储结构
把同深度的满二叉树按从上到下，从左到右的顺序给结点编号，按编号储存。仅适用于完全二叉树。
``` c
// --- 二叉树的顺序存储表示 ---
#define MAX_TREE_SIZE 100
typedef TElemType SqBiTree[MAX_TREE_SIZE];
SqBiTree bt;
```

#### 链式存储结构
``` c
// --- 二叉树的二叉链表存储表示 ---
typedef struct BiTNode{
    TElemType      data;
    struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;
// --- 二叉树的三叉链表存储表示 ---
typedef struct TriTNode{
    TElemType       data;
    struct TriTNode *lchild, *rchild;
    struct TriTNode *parent;
}TriTNode, *TriTree;
```

#### 遍历
**遍历二叉树**（traversing binary tree）按某条搜索路径巡访树中每个结点，使得每个结点均被访问一次且只被访问一次。  
若将访问根节点记作D，遍历根的左子树记作L，遍历根的右子树记作R，则先序遍历访问次序为 DLR，中序遍历访问次序为 LDR，后序遍历访问次序为 LRD。
``` c
Status PreorderTraverse(BiTree T, Status(*Visit)(TElemType e)){
    // 先序遍历二叉树的递归算法
    if(T){
        if(Visit(T->data))
            if(PreorderTraverse(T->lchild, Visit))
                if(PreorderTraverse(T->rchild, Visit))
                    return OK;
        return ERROR;
    }else return OK;
}
Status PreorderTraverse(BiTree T, Status (*Visit)(TElemType e)){
    // 先序遍历二叉树的迭代算法
    stack S;
    BiTree p;
    InitStack(S);
    if(T)  Push(S, T);
    while(!StackEmpty(S)){
        Pop(S, p);  Visit(p->data);
        if(p->rchild)  Push(S, p->rchild);
        if(p->lchild)  Push(S, p->lchild);
    }
}
```

### 线索二叉树
#### 基本概念
二叉树的遍历实际上是将二叉树的非线性结构线性化，使任一数据都有它的前驱和后继，但这种信息只有在遍历过程中才能得到。将某种遍历顺序下的前驱、后继关系（线索）记在树的存储结构中，称为二叉树的**线索化**。  
加上线索的二叉树称为**线索二叉树**（threaded binary tree）。

#### 构造
$n$ 个结点的二叉树必有 $n+1$ 个空链域，可利用这些空链域进行线索化。
``` c
typedef enum PointerTag{Link, Thread}; // Link==0:指针，Thread==1:线索
typedef struct BiThrNode{
    TElemType        data;
    struct BiThrNode *lchild, *rchild; // 左右指针
    PointerTag       LTag, RTag;       // 左右标志
}BiThrNode, *BiThrTree;

Status InOrderTraverse_Thr(BiThrTree T, Status(*Visit)(TElemType e)){
    // T 指向头结点，头结点的左链指向根节点，可参见线索化算法。
    // 中序遍历线索二叉树的非递归算法。
    BiThrTree p = T->lchild;
    while(p != T){
        while(p->LTag == Link) p = p->lchild;
        if(!Visit(p->data)) return ERROR;
        while(p->RTag == Thread && p->rchild != T){
            p = p->rchild;  Visit(p->data);
        }
        p = p->rchild;
    }
    return OK;
}

BiThrTree pre;   // 全局变量，始终指向刚访问的结点。
Status InOrderThreading(BiThrTree* Thrt, BiThrTree T){
    // 中序遍历二叉树 T，并将其中序线索化，Thrt 指向头结点。
    if(!(Thrt = (BiThrTree)malloc(sizeof(BiThrNode)))) exit(OVERFLOW);
    Thrt->LTag = Link;  Thrt->RTag = Thread;
    Thrt->rchild = Thrt;
    if(!T) Thrt->lchild = Thrt;
    else{
        Thrt->lchild = T;  pre = Thrt;
        InThreading(T);
        pre->rchild = Thrt;  pre->RTag = Thread;  // 最后一个结点线索化
        Thrt->rchild = pre;
    }
    return OK;
}
void InThreading(BiThrTree p){
    if(p){
        InThreading(p->lchild);
        if(!p->lchild){p->LTag = Thread; p->lchild = pre;}      // 前驱线索
        if(!pre->rchild){pre->RTag = Thread; pre->rchild = p;}  // 后继线索
        pre = p;
        InThreading(p->child);
    }
}
```

### 树和森林
#### 存储结构
``` c
#define MAX_TREE_SIZE 100
// --- 树的双亲表存储表示 ---
typedef struct PTNode{
    TElemType data;
    int       parent;    // 双亲位置域
}PTNode；
typedef struct{
    PTNode nodes[MAX_TREE_SIZE];
    int    r, n;     // 根的位置和结点数
}PTree;
// --- 树的孩子链表存储表示 ---
typedef struct CTNode{
    int    child;
    CTNode *next;
}*ChildPtr;
typedef struct{
    TElemType data;
    ChildPtr  firstchild;  // 孩子链表头指针
}CTBox;
typedef struct{
    CTBox nodes[MAX_TREE_SIZE];
    int   n, r;     // 结点数和根的位置
}CTree；
// --- 树的二叉链表（孩子-兄弟）存储表示 ---
typedef struct CSNode{
    ElemType data;
    CSNode   *firstchild, *nextsibling;
}CSNode, *CSTree;
```
#### 遍历
若将森林中所有树的根结点看作兄弟，可实现森林与二叉树的互相转换。  
可对树进行先根次序遍历（先访问根节点，依次先根遍历各棵子树）和后根次序遍历（先依次后根遍历各课子树，再访问根节点），分别对应二叉树的前序遍历和中序遍历。

### 二叉排序树
#### 概念
二叉排序树（binary sort tree, BST），是指一棵空树或者具有下列性质的二叉树：
1. 若任意结点的左子树不空，则左子树上所有结点的值均小于它的根节点的值；
2. 若任意结点的右子树不空，则右子树上所有结点的值均大于它的根节点的值；
3. 任意结点的左、右子树也分别为二叉查找树。
4. 每个结点的值互不相同。

可知中序遍历二叉排序树会得到一个递增序列。
#### 删除操作
``` c
Status Delete(BiTree *p){
    // 从二叉排序树中删除结点 p，并重接它的左或右子树
    if(!p->rchild){        // 右子树空则只需重接它的左子树
        BiTree *q = p;  p = p->lchild;  free(q);
    }else if(!p->lchild){  // 左子树空则只需重接它的右子树
        BiTree *q = p;  p = p->rchild;  free(q);
    }else{                 // 左右子树均不空
        BiTree *q = p;
        BiTree *s = p->lchild;
        while(s->rchild){q = s; s = s->rchild;}
        p->data = s->data;
        if(q != p) q->rchild = s->lchild;
        else q->lchild = s->lchild;
        free(s);
    }
    return OK;
}
```

#### 查找分析
二叉排序树上的查找次数不会超过二叉树的深度，而具有 $n$ 个结点的二叉排序树的深度最好为 $\log n$，最坏为 $n$。

### 平衡二叉树
#### 概念
平衡二叉树（balanced binary tree）是空树或者具有下列性质的二叉树：
1. 左子树和右子树的深度之差的绝对值不大于1
2. 左子树和右子树也都是平衡二叉树

该结点的左子树深度减去右子树深度称为该结点的**平衡因子**（balance factor）。  
最经典的平衡二叉排序树称为**AVL树**，变种有红黑树等。

#### 旋转
每插入一个新结点时，相关结点的平衡状态会发生改变。因此在插入一个新结点后，需要从插入位置沿通向根的路径回溯，检查各结点的平衡因子。  
树的平衡化基于树旋转操作。

### 哈夫曼（Huffman）树
#### 哈夫曼编码
