## 图
### 图的基本概念
* **图**中的数据元素通常称作**顶点**（vertex），若两个顶点之间存在关系，则 $<v, w>$ 可表示从顶点 $v$ 到顶点 $w$ 的一条**弧**（arc），且称 $v$ 为**弧尾**（tail）或初始点（initial node），$w$ 为**弧头**（head）或终端点（terminal node），此时的图称为**有向图**（digraph）。若有 $<v, w>$ 则必有 $<w, v>$ ，即顶点之间的关系集合是对称的，则以无序对 $(v, w)$ 代替两个有序对，表示 $v$ 和 $w$ 之间的一条**边**（edge），此时的图称为**无向图**（undigraph）。
* 每条边连接两个不同的顶点且没有两条不同的边连接一对相同顶点的图称为**简单图**（simple graph），反之称为**多重图**（multi graph）。在每对不同顶点之间都恰好有一条边的简单图，即有 $n(n-1)/2$ 条边的无向图称为**完全图**（complete graph），有 $n(n-1)$ 条弧的有向图称为**有向完全图**。
* 有很少边或弧的图 （$e<n\log n$）的图称为**稀疏图**（sparse graph），反之称为**稠密图**（dense graph）。
* 有时图的边或弧具有与它相关的数，叫做**权**（weight），权可表示一个顶点到另一个顶点的距离或耗费。带权的图通常称为**网**（network）。
* 假设有两个图 $G=(V,{E})$ 和 $G'=(V',{E'})$，如果 $V'\subset V$ 且 $E'\subset E$，则称 $G'$ 是 $G$ 的**子图**（subgraph）。如果 $V'=V$ 且 $E'\subset E$，则 $G'$ 是 $G$ 的**生成子图**（spanning subgraph）。
* 对于无向图，如果有边 $(v, w)$，则称顶点 $v$ 和 $w$ 互为**邻接点**（adjacent），即 $v$ 和 $w$ 相邻接。边 $(v, w)$ **依附**（incident）于顶点 $v$ 和 $w$。顶点 $v$ 的**度**（degree）是和 $v$ 相关联的边的数目，记为 $TD(v)$。**握手定理**（handshaking theorem）：所有顶点的度的和是图中边的2倍。
* 对于有向图，如果有弧 $<v, w>$，则称顶点 $v$ 邻接到顶点 $w$，顶点 $w$ 邻接自顶点 $v$。弧 $(v, w)$ 和顶点 $v$， $w$ 相关联。以顶点 $v$ 为头的弧的数目称为 $v$ 的**入度**（indegree），记为 $ID(v)$；以顶点 $v$ 为尾的弧的数目称为 $v$ 的**出度**（outdegree），记为 $OD(v)$；顶点 $v$ 的度为出度和入度之和，即 $TD(v)=ID(v)+OD(v)$。

### 图的存储
#### 邻接矩阵法
以一维数组存储顶点信息，以二维数组存储边或弧的信息。
``` c
// --- 图的数组（邻接矩阵）存储表示 ---
# define INFINITY       INT_MAX            // 最大值
# define MAX_VERTEX_NUM 20                 // 最大顶点个数
typedef enum {DG, DN, UDG, UDN} GraphKind; // {有向图，有向网，无向图，无向网}
typedef struct ArcCell{
    VRType   adj;     // 顶点关系类型。对无权图用1或0表示是否相邻，对带权图则为权值类型。
    InfoType *info;   // 该弧相关关系的指针
}ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];
typedef struct{
    VertexType vexs[MAX_VERTEX_NUM];  // 顶点向量
    AdjMatrix  arcs;                  // 邻接矩阵
    int        vexnum, arcnum;        // 图的当前顶点数和弧数
    GraphKind  kind;                  // 图的种类标志
}MGraph;
```

#### 邻接表法
链式存储，对每个顶点建立一个单链表来表示依附于该顶点的边或以该顶点为尾的弧。
``` c
// --- 无向图的邻接表存储表示 ---
# define MAC_VERTEX_NUM 20
typedef struct node{
    int  vindex;  // 邻接点在头结点数组中的位置（索引）
    node *next;   // 指向下一个表结点
}NodeLink;   // 表结点类型定义
typedef struct VNode{
    VertexType data;     // 顶点指针
    NodeLink   *first;   // 指向第一条依附该顶点的边的指针
}VNode, AdjList[MAX_VERTEX_NUM];
typedef struct{
    AdjList v;
    int     vexnum, arcnum;  // 图的当前顶点数和弧数
    int     kind;            // 图的种类标志
}ALGraph；
```

### 图的遍历操作
从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做**图的遍历**（traversing graph）。

#### 深度优先搜索
深度优先搜索（depth-first search, dfs）是树的先根遍历的推广。
``` c
// 采用邻接表存储表示
int visited[MAX_VERTEX_NUM];  // 访问标志数组
void DFS(AGraph *g, int x){
    NodeLink *p;
    visited[x] = 1;
    VisitFunc(g->v[x]);
    p = g->v[x].first;
    while(p){
        if(!visited[p->vindex])  // 对 x 的尚未访问的邻接顶点
            DFS(g, p->vindex);
        p = p->next;
    }
}
void DFSGraph(AGraph *g){
    // 对图 G 作深度优先遍历
    int i;
    for(i = 0; i < g->vexnum; i++)
        visited[i] = 0;    // 访问标志数组初始化
    for(i = 0; i < g->vexnum; i++)
        if(!visited[i])  DFS(g, i);
}
```
时间复杂度为 $O(n+e)$。

#### 广度优先搜索
广度优先搜索（broadth-first search, bfs）类似于树的按层次遍历的过程。
``` c
int visited[MAX_VERTEX_NUM];  // 访问标志数组
void BFS(AGraph *g, int x){
    // 用一个数组 q 作辅助队列，q[0, front) 存放的是访问过的顶点
    // q[front, rear) 存放的是已访问顶点的相邻点，是马上要访问的顶点
    int q[MAX_VERTEX_NUM], front, rear, i;
    NodeLink *p;
    front = rear = 0;
    q[rear++] = x;
    while(front != rear){
        x = q[front++];  // 顶点出队列并访问它
        VisitFunc(g->v[x]); visited[x] = 1;
        p = g->v[x].first;
        while(p != NULL){
            for(i = 0; i < rear; i++)  // 判断邻接点是否在数组 q 中
                if(p->vindex == q[i]) break;
            if(i == rear)  // 邻接点未访问且不在队列中，则入队列
                q[rear++] = p->vindex;
            p = p->next;   // 找 x 的下一个邻接点
        }
    }
}
void BFSGraph(AGraph *g){
    // 对图 G 作广度优先遍历
    int i;
    for(i = 0; i < g->vexnum; i++)
        visited[i] = 0;    // 访问标志数组初始化
    for(i = 0; i < g->vexnum; i++)
        if(!visited[i])  BFS(g, i);
}
```
时间复杂度为 $O(n+e)$。

### 原理与实现
#### 最小生成树
##### 概念
* 无向图 $G=(V, {E})$ 中从顶点 $v$ 到 $v'$ 的**路径**（path）是一个顶点序列（$v=v_{i,0},v_{i,1},\cdots,v_{i,m}=v'$），其中 $(v_{i,j-1}, v_{i,j})\in E, 1\geq j\geq m$。如果 $G$ 是有向图，则路径也是有向的。路径的长度是路径上的边或弧的数目。第一个顶点和最后一个顶点相同的路径称为**回路**或**环**（cycle）。序列中顶点不重复出现的路径称为**简单路径**。 
* 在无向图中，如果两个顶点之间有路径，则称这两个顶点是**连通**的。图中任意两个顶点都是连通的，则称图为**连通图**（connected graph）。图的极大连通子图称为**连通分量**（connected component）。
* 在有向图中，如果任意两个顶点之间正向、反向都是连通的，则称图为**强连通图**（strongly connected graph）。图的极大强连通子图称为有向图的**强连通分量**。
* 连通图的**生成树**是一个极小连通子图，它含有图中全部定点和足以构成一棵树的 $n-1$ 条边。有向图的**生成森林**由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵互不相交有向树的弧。
* 若从一个连通图中删去某个顶点和与其相关联的边，该连通图被分割成两个或两个以上的连通分量，则称此顶点为**关节点**（articulation point）或**割点**（cut point）。没有关节点的连通图为**重（双）连通图**（biconnected graph）。
* 带权连通图 $G$ 上的最小代价生成树（minimum cost spanning tree, MST）。

##### 普里姆（Prim）算法
##### 克鲁斯卡尔（Kruskal）算法

#### 最短路径
#### 关键路径
#### 拓扑排序算法
##### 概念
* 若集合上的某关系是自反的、反对称的和传递的，则称该关系是该集合上的**偏序**（partial order）关系，设 $R$ 是集合 $A$ 上的偏序关系，且 $\forall a, b \in A$，必有 $aRb$ 或 $bRa$，即集合中任何两个元素都可互相比较，则称 $R$ 是集合 $A$ 上的**全序关系**。由某个集合上的一个偏序得到该集合上的一个全序的操作称为**拓扑排序**（topological sort）。
* 可以用**有向无环图**（directed acycling graph, DAG）表示集合元素及元素之间的关系。
* 用顶点表示活动，用弧表示活动间优先关系的有向图称为 **AOV 网**（activity on vertex network）。

##### 算法
1. 在 AOV 网中选择一个没有前驱的顶点并输出。选择不同顶点会产生不同的拓扑排序结果。
2. 在 AOV 网中删除该顶点以及从该顶点出发的所有弧。
3. 重复执行前两步，直到图中所有顶点都已输出（图中无环）或图中不存在无前驱的顶点（图中必有环）。

时间复杂度为 $O(n+e)$。
