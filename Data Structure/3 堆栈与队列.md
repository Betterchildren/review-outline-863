## 堆栈
### 基本概念
**栈**是限制在线性表的一端进行插入和删除操作的线性表，也称为后进先出（Last In First Out, LIFO）线性表。  
**栈顶**（top）允许进行插入、删除操作的一段，也称为表尾。  
**栈底**（bottom）固定端，也称为表头。  
**空栈** 表中没有元素。

#### 基本操作
**进栈**（push）、**出栈**（pop）。  
初始化、求长、判空……

### 构造原理
#### 顺序存储结构
``` c
// --- 栈的动态分配顺序存储结构 ---
#define STACK_INIT_SIZE 100   // 存储空间初始分配量
#define STACKINCREMENT  10    // 存储空间分配增量
typedef struct {
    SElemType  *base;   // 在栈构造之前和销毁之后，base 的值为 NULL
    SElemType  *top;    // 栈顶指针
    int  stacksize;     // 当前已分配的存储空间，以元素为单位
}DySqStack;
// --- 栈的静态分配顺序存储结构 ---
# define MAX_STACK_SIZE 100
typedef struct{
    SElemType stack_array[MAX_STACK_SIZE];
    int top;
}StSqStack;
```

#### 链式存储结构
``` c
typedef struct Node{
    SElemType data;
    struct Node *next;
}LinkedStack;
```

### 算法设计与实现
#### 数制转换
十进制数 $N$ 和其他 $d$ 进制数的转换基于原理： $N=(N / d)\times d + N \% d$，其中 $/$ 为整除运算，$\%$为求余运算。
``` c
void conversion(int n, int d){
    int e;
    DySqStack s;
    InitStack(&s);
    while(n){
        Push(&s, n%d);
        n = n/d;
    }
    while(!IsStackEmpty(&s)){
        Pop(&s, &e);  printf("%d", e);
    }
}
```

#### 算术表达式求值
设置 OPTR 和 OPND 两个工作栈，分别用于存放算符，和操作数及结果。
``` c
#define OPSETSIZE 7
char OPSET[OPSETSIZE]={'+', '-', '*', '/', '(', ')', '#'};
bool In(char test, char *testOp);  // 判断 test 是否属于 testOp
char precede(char a, char b);      // 返回两算符之间的优先关系
float Operate(float a, char theta, float b); // 执行四则运算
float EvaluateExpression(char* MyExpression){
    StackChar OPTR;
    StackFloat OPND;
    char TempData[20];  strcpy(TempData, '\0');
    float data, a, b;  char thera, *c, x, Dr[2];
    InitStack(OPTR);  Push(OPTR, '#');
    InitStack(OPND);  c = MyExpression;
    while(*c!='#' || GetTop(OPTR)!='#'){
        if(!In(*c, OPSET)){  // *c 不是运算符，则进运算数栈
            Dr[0] = *c; Dr[1] = '\0'; strcat(TempData, Dr);
            c++;
            if(In(*c, OPSET)){
                data = (float)atof(TempData); Push(OPND, data);
                strcpy(TempData, '\0');
            }
        } else {       // *c 是运算符，则根据它与栈顶的优先关系做相应的操作
            switch(precede(GetTop(OPTR), *c)){
                case '<':   // 栈顶元素优先级低，则将读到的算符进栈
                    Push(OPTR, *c); c++; break;
                case '=':   // 脱括号并接受下一字符
                    Pop(OPTR, &x); c++; break;
                case '>':   // 栈顶算符出栈并将运算结果入操作数栈
                    Pop(OPTR, &theta); Pop(OPND, &b); Pop(OPND, &a);
                    Push(OPND, Operate(a, theta, b)); break;
            }// switch
        }// if
    }// while
    return GetTop(OPND);
}
```

#### 递归的实现
**递归**（recursive）一个函数直接或间接地调用自己。有效的递归包括两部分：递推规则和终止条件。  
**例**（Hanoi 塔）：假设有三个分别命名为 X、Y 和 Z 的柱子，在柱子 X 上有 n 个直径大小各不相同、从小到大编号为1，2，…n 的圆盘。现要求将圆盘移至 Z 柱上并按同样顺序叠排，圆盘移动时必须遵循下列规则：每次只能移动一个圆盘；圆盘可以插在任一柱之上；任何时刻都不能将一个较大的圆盘压在较小的圆盘之上。  
解：
``` c
int c = 0;
void move(char x, int n, char z){
    printf("%2d. Move disk %d from %c to %c.\n", ++c, n, x, z);
}
void hanoi(int n, char x, char y, char z){
    if(n == 1)
        move(x, 1, z);         // 将编号为1的圆盘从 x 移到 z
    else{
        hanoi(n-1, x, z, y);   // 将 x 上编号为1至n-1的圆盘移到 y，z 作辅助塔
        move(x, n, z);         // 将编号为n的圆盘从 x 移到 z
        hanoi(n-1, y, x, z);   // 将 y 上编号为1至n-1的圆盘移到 z，x 作辅助塔
    }
}
```
每进入一层递归，就产生一个新的工作记录压入栈顶；每退出一层递归，就从栈顶弹出一个工作记录。

## 队列
### 基本概念
#### 基本操作

### 构造原理
#### 顺序存储结构
#### 链式存储结构

### 算法设计与实现
