## 存储器管理
**理解存储管理的功能及存储管理对多道程序设计的支持；掌握段、页式存储管理方法及实现技术；掌握虚存的原理及相关的各种算法和数据结构。**

### 分区存储管理
为了能在内存中装入多道程序，且使这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的区域，每个区域中只装入一道作业。
* 覆盖：把用户空间分为一个固定区和若干个覆盖区，将经常活跃的部分放在固定区，其余部分在用到时调入覆盖。
* 交换：把处于阻塞状态或睡眠状态下的进程从内存换到辅存，把处于就绪状态但已被换出的进程换入内存。

### 页式管理及段式管理
#### 页式管理
* 将用户程序的地址空间分为若干个大小相等区域，称为页或页面（page），相应地将内存空间分为若干个与页大小相同的页框（frame）。
* 需要一个页表来记录虚页到物理页，即页到页框的映射。页表中还存有相应页的控制位。

#### 段式管理
* 把程序逻辑上划分为若干段：代码、栈、堆等。每个段分配连续内存，段间不必连续。每个段采用基址+长度。
* 每个进程有一个段表，存储段号到基址的映射、该段最大长度和该段的控制位。

| 维度 | 分段 | 分页 |
| --- | --- | --- |
| 映射粒度 | 大，且不固定长度 | 小，且固定长度 |
| 内存利用率 | 外部碎片 | 内部碎片 |
| 程序员感知 | 感知 | 不感知 |
| 进程地址空间 > 物理内存 | 支持 | 支持 |
| 保护 | 区分过程与数据，可以有不同的保护 | 按页保护，不区分页的内容 |

### 段、页式存储管理方法及实现技术
先将进程划分为若干段，每个段采用分页管理，段表记录其页表地址。

### 虚存的原理及相关的各种算法和数据结构
程序运行时，在时间和空间上均有局部性原理。虚存利用了这一原理，在程序运行之前仅需将当前需要的少数页面或段先装入内存便可运行。程序运行时如果需要访问的页（段）已在内存中，便可继续运行；如果不在内存中，便可调入或换入内存中继续运行。  
替换算法：
* 最佳（OPT）置换算法：将以后永不使用的，或者是在最长时间内不再被访问的页面换出，可以保证最低的缺页率。但目前无法预知哪个页面是未来最长时间内不会被访问的，所以该算法无法实现。
* 先进先出（FIFO）置换算法：将最早进入内存的页面换出。实现上很简单，只需将调入内存的页面按时间先后顺序组成一个链表，指针指向最先调入的页面即可。但会出现分配的页框数增多但缺页率反而增大的情况，称为 **Belady 异常**。
* 最久未使用（LRU）算法：将最长时间没有被使用过的页面换出。需要硬件支持：
	* 寄存器：每个页配有一个移位寄存器，每次访问后将寄存器最高位置1，每隔一段时间将所有寄存器右移一位。要换出时，选择寄存器值最小的换出。
	* 栈：用一个大小与页框数相同的栈保存页号，当使用一个页时，将页号从栈中取出，再压入栈。要换出时，选择栈底的页进行换出。
* 时钟（CLOCK）算法（也称为最近未使用（NRU）算法）：给每个页设置一个使用位标志，每次访问都置1。把所有页组织成环形链表，用一个指针指向页。当需要换出时，指针沿链表检查，遇到使用位为1的页就置为0然后检查下一个页面，遇到使用位为0的页就换出。
* 改进型 CLOCK 算法：在使用位（u）的基础上增加修改位（m）。指针第一次扫描时不作任何改动，找到 `!u && !m` 的页就换出；若没有，第二次扫描时将使用位置0，同时寻找 `!u && m` 的位，找到则换出；若仍没有，再重复第一步和第二步。由于换出的过程中若页的内容有修改，需要写入磁盘；故改进之处在于优先寻找没有修改的页，减少了磁盘 I/O 操作。
